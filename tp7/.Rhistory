#X_n+1 = X_n si X_n < 90% et pi < 0.5
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < 90% et pi >= 0.5
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.7 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
if(p < V) {
dispo <- 100 - poubelle[n-1]
print(dispo)
poubelle[n] = poubelle[n-1] + sample(c(0:dispo/4), 1, replace = TRUE)
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'un produit en pourcentage
#Selon une loi normale, la caisse se vide ou non
#X_n+1 = X_n si X_n >Xmin et pi < V
#X_n+1 = X_n - RAND (0, X_n) si X_n > Xmin et pi <= V
#X_n+1 = 100 si X_n <= Xmin
#Initialisation
Xmin <- 20 #Niveau(%) déclenchant le remplissage
V <- 0.7 #Niveau de vitesse de vidage (0-1) : plus V est grand, plus les produits partent vite
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Remplissage d'un produit en pourcentage
#Selon une loi normale, la caisse se vide ou non
#X_n+1 = X_n si X_n >Xmin et pi > V
#X_n+1 = X_n - RAND (0, X_n) si X_n > Xmin et pi <= V
#X_n+1 = 100 si X_n <= Xmin
#Initialisation
Xmin <- 20 #Niveau(%) déclenchant le remplissage
V <- 0.7 #Niveau de vitesse de vidage (0-1) : plus V est grand, plus les produits partent vite
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
produits <- vector(length = N)
produits[1] <- X0
for(n in 2:N) {
if(produits[n-1] <= Xmin) {
produits[n] <- 100
} else {
p <- runif(1,0,1)
if(p < V) {
produits[n] = produits[n-1] - sample(c(0:produits[n-1]), 1, replace = TRUE)
} else {
produits[n] = produits[n-1]
}
}
}
produits
plot(produits, type="l")
#Remplissage d'un produit en pourcentage
#Selon une loi normale, la caisse se vide ou non
#X_n+1 = X_n si X_n >Xmin et pi > V
#X_n+1 = X_n - RAND (0, X_n) si X_n > Xmin et pi <= V
#X_n+1 = 100 si X_n <= Xmin
#Initialisation
Xmin <- 20 #Niveau(%) déclenchant le remplissage
V <- 0.5 #Niveau de vitesse de vidage (0-1) : plus V est grand, plus les produits partent vite
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
produits <- vector(length = N)
produits[1] <- X0
for(n in 2:N) {
if(produits[n-1] <= Xmin) {
produits[n] <- 100
} else {
p <- runif(1,0,1)
if(p < V) {
produits[n] = produits[n-1] - sample(c(0:produits[n-1]), 1, replace = TRUE)
} else {
produits[n] = produits[n-1]
}
}
}
produits
plot(produits, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.7 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.5 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.5 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.3 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.3 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 130 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.4 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 130 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.4 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 130 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.4 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 130 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'une poubelle en pourcentage
#Selon une loi normale, la poubelle se remplit ou non
#X_n+1 = X_n si X_n < Xmax et pi < V
#X_n+1 = X_n + RAND (0, 100-X_n) si X_n < Xmax et pi >= V
#X_n+1 = 0 si X_n >= 90%
#Initialisation
Xmax <- 85 #Remplissage (%) avant entretien
V <- 0.4 #Niveau de vitesse de rempissage (0-1) : plus V est grand, plus la poubelle se remplit vite
vol <- 10 #volumétrie objets à jeter : pourcentage max qu'un objet peut prendre dans la poubelle
N <- 130 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
poubelle <- vector(length = N)
poubelle[1] <- X0
for(n in 2:N) {
if(poubelle[n-1] >= Xmax) {
poubelle[n] <- 0
} else {
p <- runif(1,0,1)
print(p)
if(p < V) {
dispo <- 100 - poubelle[n-1]
repeat {
jete <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= dispo)
break;
}
poubelle[n] = poubelle[n-1] + jete
} else {
poubelle[n] = poubelle[n-1]
}
}
}
poubelle
plot(poubelle, type="l")
#Remplissage d'un produit en pourcentage
#Selon une loi normale, la caisse se vide ou non
#X_n+1 = X_n si X_n >Xmin et pi > V
#X_n+1 = X_n - RAND (0, X_n) si X_n > Xmin et pi <= V
#X_n+1 = 100 si X_n <= Xmin
#Initialisation
Xmin <- 20 #Niveau(%) déclenchant le remplissage
V <- 0.5 #Niveau de vitesse de vidage (0-1) : plus V est grand, plus les produits partent vite
vol <- 20 #volume max de produits pris en même temps
N <- 100 #Nombre de données voulues
X0 <- sample(c(0:100), 1, replace = TRUE) #Niveau de remplissage initial aléatoire
#Calculs
produits <- vector(length = N)
produits[1] <- X0
for(n in 2:N) {
if(produits[n-1] <= Xmin) {
produits[n] <- 100
} else {
p <- runif(1,0,1)
if(p < V) {
repeat {
pris <-  sample(c(0:vol), 1, replace = TRUE)
if (jete <= produits[n-1])
break;
}
produits[n] = produits[n-1] - pris
} else {
produits[n] = produits[n-1]
}
}
}
produits
plot(produits, type="l")
data <- load("data_expressions.RData")
X # données
y # classification
X[i] #
I<-matrix(X[i,],60,70)
I1 <- apply(I, 1, rev)
image(t(I1),col=gray(0:255 / 255))
data_not_null <- matrix(nrow=216)
for (i in 1:4200){ if (X[,i]!=0){ data_not_null <- cbind(data_not_null, X[,i]) }}
data_not_null <- data_not_null[,2:ncol(data_not_null)]
data_acp <- prcomp(data_not_null) # scale =TRUE données normées, pas princomp trop de variables par rapport au nombre d'individus
#package factoextra pour la foncion get_pca_var
data_acp <- prcomp(data_not_null)
# scale =TRUE données normées, pas princomp trop de variables par rapport au nombre d'individus
plot(data_acp$x, col=palette()[y])
legend(-1000, 2500 , title= "Expressions faciales", inset=.001,  c("1", "2", "3","4","5", "6"), fill=palette(), horiz=TRUE, xpd=TRUE)
pairs(data_acp$x[,1:5], col=palette()[y])
# variance cumulées avec 2 composates : 21 %, 21 composantes : 70%
# avec le pot, on distingue les groupes mais difficile
acp.data_not_null <- prcomp(data_not_null)
data.acp.train <- acp.data_not_null$x[dtrain,]
data.acp.test <- acp.data_not_null$x[-dtrain,]
data.acp.trainclass <- y[dtrain,]
data.acp.testclass <- y[-dtrain,]
source("exp_faciales_data.R")
data_acp <- prcomp(data_not_null)
# scale =TRUE données normées, pas princomp trop de variables par rapport au nombre d'individus
plot(data_acp$x, col=palette()[y])
legend(-1000, 2500 , title= "Expressions faciales", inset=.001,  c("1", "2", "3","4","5", "6"), fill=palette(), horiz=TRUE, xpd=TRUE)
pairs(data_acp$x[,1:5], col=palette()[y])
# variance cumulées avec 2 composates : 21 %, 21 composantes : 70%
# avec le pot, on distingue les groupes mais difficile
acp.data_not_null <- prcomp(data_not_null)
data.acp.train <- acp.data_not_null$x[dtrain,]
data.acp.test <- acp.data_not_null$x[-dtrain,]
data.acp.trainclass <- y[dtrain,]
data.acp.testclass <- y[-dtrain,]
setwd("~/Documents/anaig/Compiegne/GI05/SY19/git/SY19/tp7")
data <- load("data_expressions.RData")
X # données
y # classification
#Les données consistent en une matrice X de taille 216 × 4200 et un vecteur y de longueur 216.
#Chaque ligne X[i,] contient les niveaux de gris d’une image de taille 60 × 70.
# X -> 4200 colonnes et 216 lignes, 216 individus et 4200 variables
# y -> 1 colonnes  et 216 lignes,  valeurs possibles -> 1 à 6
#Visualisation des images
i=2 # exemple
I<-matrix(X[i,],60,70)
I1 <- apply(I, 1, rev)
image(t(I1),col=gray(0:255 / 255))
data_not_null <- matrix(nrow=216)
for (i in 1:4200){ if (X[,i]!=0){ data_not_null <- cbind(data_not_null, X[,i]) }}
data_not_null <- data_not_null[,2:ncol(data_not_null)]
non_cor <- sweep(data_not_null, 2, colSums(data_not_null)/216) # variables centrées/réduites
#ensemble d'apprentissage et de test
n <- nrow(data_not_null)
ntrain <- floor(2/3*n)
ntest <- n - ntrain
dtrain <- sample(1:n, ntrain)
data.train <- data_not_null[dtrain,]
data.test <- data_not_null[-dtrain,]
data.trainclass <- y[dtrain,]
data.testclass <- y[-dtrain,]
install.packages(c("date", "mclust", "pls", "Rcpp", "zoo"))
install.packages("~/Downloads/FactoMineR_1.34.tar.gz", repos = NULL, type = "source")
install.packages("car")
install.packages("~/Downloads/FactoMineR_1.34.tar.gz", repos = NULL, type = "source")
install.packages("ellipse")
install.packages("flashClust")
install.packages("scatterplot3d")
install.packages("knitr")
install.packages("~/Downloads/FactoMineR_1.34.tar.gz", repos = NULL, type = "source")
?fda
library(fa$)
library(FactoMineR)
